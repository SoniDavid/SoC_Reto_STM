/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include <string.h>  // Añade esto para strlen()
#include "main.h"
#include "user_uart.h"
#include "user_tim.h"
#include "user_core_cm0plus.h"

#define RX_BUFFER_SIZE 64

volatile float rpm = 0.0f, vl = 0.0f;
volatile float gear = 0.0f;
volatile uint8_t paqueteListo = 0;

volatile uint32_t tim16_tick = 0;
char rx_buffer[RX_BUFFER_SIZE];
uint8_t rx_index = 0;

void transmit_data(void);
void USER_GPIO_Init(void);
void USER_RCC_Init(void);
uint8_t delay_elapsed(uint32_t *start, uint32_t n_ticks);

int main(void)
{
	/* Declarations and Initializations*/
	USER_RCC_Init( );
	USER_GPIO_Init();
	USER_USART1_Init();
	USER_SysTick_Init();
	USER_TIM16_Init();
   /* Repetitive block*/

	uint32_t start_tx = 0;
	uint32_t start_led = 0;

	for(;;){

		if (paqueteListo) {
			paqueteListo = 0;
			// Aquí puedes procesar los datos almacenados en rpm, vl y gear
		}

		if (delay_elapsed(&start_tx, 100)) {
			transmit_data();
		}

		if (delay_elapsed(&start_led, 100)) {
			GPIOA->ODR ^= (0x1UL << 5U); // Toggle USER LED
		}
	}
}

void USART1_IRQHandler(void) {
    if (USART1->ISR & (1UL << 5U)) { // RXNE
        uint8_t received = (uint8_t)(USART1->RDR & 0xFF);

        if(received == 'I') {
            rx_index = 0;
            memset(rx_buffer, 0, RX_BUFFER_SIZE);
            rx_buffer[rx_index++] = received;
            return;
        }

        if (rx_buffer[0] == 'I') {
            if(received == 'E') {
                rx_buffer[rx_index] = '\0';

                int rpm_i1, rpm_i2, vl_i1, vl_i2, gear_i;
                if (sscanf(&rx_buffer[1], "%d,%d,%d,%d,%d,", &rpm_i1, &rpm_i2, &vl_i1, &vl_i2, &gear_i) == 5) {
                    rpm = rpm_i1 + (rpm_i2 / 100.0f);
                    vl = vl_i1 + (vl_i2 / 100.0f);
                    gear = (float)gear_i;
                    paqueteListo = 1;
                }
            } else if (rx_index < RX_BUFFER_SIZE - 1) {
                rx_buffer[rx_index++] = received;
            } else {
                rx_index = 0;
                memset(rx_buffer, 0, RX_BUFFER_SIZE);
            }
        }
    }
}

void transmit_data(){
	uint8_t tx_buffer[64];
	int rpm_i = (int)(rpm * 100);
	int vl_i = (int)(vl * 100);
	int gear_i = (int)(gear);
	sprintf((char*)tx_buffer,
		             "I%d.%02d,%d.%02d,%d,E\n",
		             rpm_i / 100, rpm_i % 100,
		             vl_i / 100,  vl_i % 100,
		             gear_i);
	USER_USART1_Transmit(tx_buffer, strlen((char*)tx_buffer));
}

void USER_GPIO_Init( void ) {
	// Enable GPIOA clock
	RCC->IOPENR	= RCC->IOPENR   |  ( 0x1UL <<  0U );
	// Configure PA5 as output push pull
	GPIOA->BSRR   = 0x1UL << 21U; // Reset PA5 low to turn off LED
	GPIOA->PUPDR  = GPIOA->PUPDR  & ~( 0x3UL << 10U ); // Clear pull-up/pull-down bits for PA5
	GPIOA->OTYPER = GPIOA->OTYPER & ~( 0x1UL <<  5U ); // Clear output type bit for PA5
	GPIOA->MODER  = GPIOA->MODER  & ~( 0x2UL << 10U ); // Set PA5 as output
	GPIOA->MODER  = GPIOA->MODER  |  ( 0x1UL << 10U ); // Set PA5 as output
}

void USER_RCC_Init( void ){
	/* System Clock (SYSCLK) configuration for 48 MHz */
	FLASH->ACR	&= ~( 0x6UL <<  0U );// 2 HCLK cycles latency, if SYSCLK >=24MHz <=48MHz
	FLASH->ACR	|=  ( 0x1UL <<  0U );// 2 HCLK cycles latency, if SYSCLK >=24MHz <=48MHz
	while(( FLASH->ACR & ( 0x7UL <<  0U )) != 0x001UL );// wait until LATENCY[2:0]=001
	RCC->CR		&= ~( 0x7UL << 11U );// select HSISYS division factor by 1
	while(!( RCC->CR & ( 0x1UL << 10U )));// wait until HSISYS is stable and ready
	RCC->CFGR	&= ~( 0x7UL <<  0U );// select HSISYS as the SYSCLK clock source
	RCC->CFGR	&= ~( 0x1UL << 11U );// select HCLK division factor by 1
}

void TIM16_IRQHandler(void) {
    if (TIM16->SR & (1UL << 0)) {
        TIM16->SR &= ~(1UL << 0);
        tim16_tick++;
    }
}

uint8_t delay_elapsed(uint32_t *start, uint32_t n_ticks) {
    if ((tim16_tick - *start) >= n_ticks) {
        *start = tim16_tick;
        return 1;
    }
    return 0;
}

